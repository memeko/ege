import random
import ipaddress

def generate_network_with_nonzero_last_octet():
    """Генерирует адрес сети, где последний октет ≠ 0"""
    while True:
        # Генерируем первые 3 октета
        first = random.randint(1, 223)  # Исключаем multicast/зарезервированные
        second = random.randint(0, 255)
        third = random.randint(0, 255)
        
        # Генерируем последний октет (1-254)
        fourth = random.randint(1, 254)
        
        network_addr = f"{first}.{second}.{third}.{fourth}"
        
        # Проверяем, что это действительно может быть адрес сети
        # (например, 192.168.1.192/26 - валиден, а 192.168.1.5/24 - нет)
        for mask_len in range(16, 31):
            try:
                network = ipaddress.IPv4Network(f"{network_addr}/{mask_len}", strict=False)
                if str(network.network_address) == network_addr:  # Убедимся, что это именно адрес сети
                    return network_addr, mask_len
            except ValueError:
                continue

def generate_valid_ip():
    """Основная функция генерации"""
    network_addr, mask_len = generate_network_with_nonzero_last_octet()
    network = ipaddress.IPv4Network(f"{network_addr}/{mask_len}")
    
    # Генерируем валидный хост
    hosts = list(network.hosts())
    host = random.choice(hosts) if hosts else network.network_address + 1
    
    return {
        "network": network_addr,
        "mask": str(network.netmask),
        "mask_length": mask_len,
        "host": str(host),
        "is_private": network.is_private,
    }

# Пример использования
ip_info = generate_valid_ip()
print(f"Сеть: {ip_info['network']}/{ip_info['mask_length']}")
print(f"Маска: {ip_info['mask']}")
print(f"Адрес узла: {ip_info['host']}\n")

print(f"В терминологии сетей TCP/IP маской сети называют двоичное число, которое показывает, какая часть IP-адреса узла сети относится к адресу сети, а какая – к адресу узла в этой сети. Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и маске сети. Сеть задана IP-адресом {ip_info['network']} и маской сети {ip_info['mask']}.  Сколько в этой сети IP-адресов, для которых сумма единиц в двоичной записи IP-адреса кратна {random.randint(2,7)}? В ответе укажите только число.\n")
print(f"В терминологии сетей TCP/IP маской сети называется двоичное число, определяющее, какая часть IP-адреса узла сети относится к адресу сети, а какая – к адресу самого узла в этой сети. Обычно маска записывается по тем же правилам, что и IP-адрес, – в виде четырёх байтов, причём каждый байт записывается в виде десятичного числа. При этом в маске сначала (в старших разрядах) стоят единицы, а затем с некоторого разряда – нули. Адрес сети получается в результате применения поразрядной конъюнкции к заданному IP-адресу узла и маске. Для узла с IP-адресом {ip_info['host']} адрес сети равен {ip_info['network']}. Чему равен последний байт маски? Ответ запишите в виде десятичного числа. \n")
print(f"В терминологии сетей TCP/IP маской сети называется двоичное число, определяющее, какая часть IP-адреса узла сети относится к адресу сети, а какая – к адресу самого узла в этой сети. Обычно маска записывается по тем же правилам, что и IP-адрес, – в виде четырёх байтов, причём каждый байт записывается в виде десятичного числа. При этом в маске сначала (в старших разрядах) стоят единицы, а затем с некоторого разряда – нули.Адрес сети получается в результате применения поразрядной конъюнкции к заданному IP-адресу узла и маске. Для узла с IP-адресом {ip_info['host']} адрес сети равен {ip_info['network']}. Чему равно наименьшее возможное значение крайнего справа байта маски? Ответ запишите в виде десятичного числа.")
